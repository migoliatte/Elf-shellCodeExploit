from LIB.analyseElf import *
from LIB.displayHeader import display
from LIB.displayHeader import displayTest
from LIB.displayHeader import displaySectionHeaderContent


def recupData():
    HexContent = GetElf("EXECUTABLES/echoOui.elf")
    fildeHeaderContent = FILEHEADER()
    fildeHeaderContent = recupDataFileHeader(fildeHeaderContent,HexContent)    
    
    programHeaderContent = PROGRAMHEADER()
    programHeaderContent = recupDataProgramHeader(programHeaderContent,HexContent)
    

    display(fildeHeaderContent,programHeaderContent)

    sectionHeaderContent = SECTIONHEADER()
    sectionHeaderContent = recupDataSectionHeader(sectionHeaderContent,HexContent,fildeHeaderContent)
    
    displaySectionHeaderContent(sectionHeaderContent)
    
    dataProgramContent = CODEDATA()
    dataProgramContent = recupDataCode(dataProgramContent,HexContent)
    
    
    displayTest(dataProgramContent)
    

def recupDataFileHeader(fileHeaderContent: str,HexContent: str):

    for i in range(0, 8, 2):      # 32bit/64bit(0x00 + 4 bytes)
        fileHeaderContent.e_ident.ei_mag += HexContent[i]+HexContent[i+1]+' '

    for i in range(8, 10):        # 32bit/64bit(0x04 + 1 bytes)
        fileHeaderContent.e_ident.ei_class += HexContent[i]

    for i in range(10, 12):       # 32bit/64bit(0x05 + 1 bytes)
        fileHeaderContent.e_ident.ei_data += HexContent[i]

    for i in range(12, 14):       # 32bit/64bit(0x06 + 1 bytes)
        fileHeaderContent.e_ident.ei_version += HexContent[i]

    for i in range(14, 16):       # 32bit/64bit(0x07 + 1 bytes)
        fileHeaderContent.e_ident.ei_osabi += HexContent[i]

    for i in range(16, 18):       # 32bit/64bit(0x08 + 1 bytes)
        fileHeaderContent.e_ident.ei_abiversion += HexContent[i]

    for i in range(18, 32):       # 32bit/64bit(0x09 + 7 bytes)
        fileHeaderContent.e_ident.ei_pad += HexContent[i]+HexContent[i+1] 

    for i in range(32, 36, 2):    # 32bit/64bit(0x10 + 2 bytes)
        fileHeaderContent.e_type += HexContent[i]+HexContent[i+1]
       # fileHeaderContent.e_type=reverse_a_string_slowly(fileHeaderContent.e_type)
        
    for i in range(36, 40, 2):    # 32bit/64bit(0x12 + 2 bytes)
        fileHeaderContent.e_machine += HexContent[i]+HexContent[i+1] 

    for i in range(40, 48, 2):    # 32bit/64bit(0x14 + 4 bytes)
        fileHeaderContent.e_version += HexContent[i]+HexContent[i+1] 

    #on part de l'idée qu'on est en 64 bits pour l'instant

    for i in range(48, 64, 2):    # 32bit(0x18 + 4 bytes)/64bit(0x18 + 8 bytes)
        fileHeaderContent.e_entry += HexContent[i]+HexContent[i+1] 

    for i in range(64, 80, 2):    # 32bit(0x1C + 4 bytes)/64bit(0x20 + 8 bytes)
        fileHeaderContent.e_phoff += HexContent[i]+HexContent[i+1] 

    for i in range(80, 96, 2):    # 32bit(0x20 + 4 bytes)/64bit(0x28 + 8 bytes)
        fileHeaderContent.e_shoff += HexContent[i]+HexContent[i+1] 

    for i in range(96, 104, 2):    # 32bit(0x24 + 4 bytes)/64bit(0x30 + 4 bytes)
        fileHeaderContent.e_flags += HexContent[i]+HexContent[i+1] 

    for i in range(104, 108, 2):   # 32bit(0x28 + 2 bytes)/64bit(0x34 + 2 bytes)
        fileHeaderContent.e_ehsize += HexContent[i]+HexContent[i+1] 

    for i in range(108, 112, 2):  # 32bit(0x2A + 2 bytes)/64bit(0x36 + 2 bytes)
        fileHeaderContent.e_phentsize += HexContent[i]+HexContent[i+1] 

    for i in range(112, 116, 2):  # 32bit(0x2C + 2 bytes)/64bit(0x38 + 2 bytes)
        fileHeaderContent.e_phnum += HexContent[i]+HexContent[i+1] 

    for i in range(116, 120, 2):  # 32bit(0x2E + 2 bytes)/64bit(0x3A + 2 bytes)
        fileHeaderContent.e_shentsize += HexContent[i]+HexContent[i+1] 

    for i in range(120, 124, 2):  # 32bit('0x30' + 2 bytes)/64bit(0x3C + 2 bytes)
        fileHeaderContent.e_shnum += HexContent[i]+HexContent[i+1] 

    for i in range(124, 128, 2):  # 32bit(0x32 + 2 bytes)/64bit(0x3E + 2 bytes)
        fileHeaderContent.e_shstrndx += HexContent[i]+HexContent[i+1] 
    
    #END# 32bit(0x34)/64bit(0x40)
    return fileHeaderContent

def recupDataProgramHeader(programHeaderContent: str,HexContent: str ):
    #on part encore sur l'idée qu'on est sur du 64 bit
    for i in range(128, 136, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.p_type += HexContent[i]+HexContent[i+1] 
    for i in range(136, 144, 2):      # 64bit(0x04 + 4 bytes)
        programHeaderContent.p_flags += HexContent[i]+HexContent[i+1] 
    for i in range(144, 160, 2):      # 32bit(0x04 + 4 bytes) / 64bit(0x08 + 8 bytes)
        programHeaderContent.p_offset += HexContent[i]+HexContent[i+1] 
    for i in range(160, 176, 2):      # 32bit(0x08 + 4 bytes) / 64bit(0x10 + 8 bytes)
        programHeaderContent.p_vaddr += HexContent[i]+HexContent[i+1] 
    for i in range(176, 192, 2):      # 32bit(0x0c + 4 bytes) / 64bit(0x18 + 8 bytes)
        programHeaderContent.p_paddr += HexContent[i]+HexContent[i+1] 
    for i in range(192, 208, 2):      # 32bit(0x10 + 4 bytes) / 64bit(0x20 + 8 bytes)
        programHeaderContent.p_filesz += HexContent[i]+HexContent[i+1] 
    for i in range(208, 224, 2):      # 32bit(0x14 + 4 bytes) / 64bit(0x28 + 8 bytes)
        programHeaderContent.p_memsz += HexContent[i]+HexContent[i+1] 
    #for i in range(218, 236, 2):      # 32bit(0x18 + 4 bytes) 
    #    programHeaderContent.p_flags += HexContent[i]+HexContent[i+1] 
    for i in range(224, 240, 2):      # 32bit(0x1C + 4 bytes) / 64bit(0x30 + 8 bytes)
        programHeaderContent.p_alin += HexContent[i]+HexContent[i+1] 
    
    #END# 32bit(0x20)/64bit(0x)
    return programHeaderContent

def recupDataCode(programHeaderContent: str,HexContent: str ):
    #on part encore sur l'idée qu'on est sur du 64 bit
    for i in range(240, 248, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.len += HexContent[i]+HexContent[i+1] 
    for i in range(248, 256, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.data += HexContent[i]+HexContent[i+1] 
    for i in range(256, 264, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.write += HexContent[i]+HexContent[i+1] 
    
    print("POSITION DU DEBUT : ",3216,"& position byte : ",hex(3216))

    for i in range(3216, 3254, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.rodata += HexContent[i]+HexContent[i+1] 
    for i in range(3216, 3254, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.sectionName += HexContent[i]+HexContent[i+1] 
    
    return programHeaderContent

def recupDataSectionHeader(programHeaderContent: str,HexContent: str, fildeHeaderContent:str ):
    #on part encore sur l'idée qu'on est sur du 64 bit
    startHeaderTable=int(fildeHeaderContent.e_shoff,16)*2#+int(fildeHeaderContent.e_phentsize,16)
    print("POSITION DU DEBUT : ",startHeaderTable,"& position byte : ",hex(startHeaderTable))

    for i in range(startHeaderTable, startHeaderTable+4*2, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.sh_name += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+4*2,"& position byte : ",hex(startHeaderTable+4*2))
    for i in range(startHeaderTable+4*2, startHeaderTable+8*2, 2):      # 64bit(0x04 + 4 bytes)
        programHeaderContent.sh_type += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+8*2,"& position byte : ",hex(startHeaderTable+8*2))
    for i in range(startHeaderTable+8*2, startHeaderTable+16*2, 2):      # 32bit(0x04 + 4 bytes) / 64bit(0x08 + 8 bytes)
        programHeaderContent.sh_flags += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+16*2,"& position byte : ",hex(startHeaderTable+16*2))
    for i in range(startHeaderTable+16*2, startHeaderTable+24*2, 2):      # 32bit(0x08 + 4 bytes) / 64bit(0x10 + 8 bytes)
        programHeaderContent.sh_addr += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+24*2,"& position byte : ",hex(startHeaderTable+24*2))
    for i in range(startHeaderTable+24*2, startHeaderTable+32*2, 2):      # 32bit(0x0c + 4 bytes) / 6+4bit(0x18 + 8 bytes)
        programHeaderContent.sh_offset += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+32*2,"& position byte : ",hex(startHeaderTable+32*2))
    for i in range(startHeaderTable+32*2, startHeaderTable+40*2, 2):      # 32bit(0x10 + 4 bytes) / 64bit(0x20 + 8 bytes)
        programHeaderContent.sh_size += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+40*2,"& position byte : ",hex(startHeaderTable+40*2))
    for i in range(startHeaderTable+40*2, startHeaderTable+48*2, 2):      # 32bit(0x14 + 4 bytes) / 64bit(0x28 + 8 bytes)
        programHeaderContent.sh_link += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+48*2,"& position byte : ",hex(startHeaderTable+48*2))
    for i in range(startHeaderTable+48*2, startHeaderTable+52*2, 2):      # 32bit(0x18 + 4 bytes) 
        programHeaderContent.sh_info += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+52*2,"& position byte : ",hex(startHeaderTable+52*2))
    for i in range(startHeaderTable+52*2, startHeaderTable+60*2, 2):      # 32bit(0x1C + 4 bytes) / 64bit(0x30 + 8 bytes)
        programHeaderContent.sh_addralign += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+60*2,"& position byte : ",hex(startHeaderTable+60*2))
    for i in range(startHeaderTable+60*2, startHeaderTable+68*2, 2):      # 32bit(0x1C + 4 bytes) / 64bit(0x30 + 8 bytes)
        programHeaderContent.sh_entsize += HexContent[i]+HexContent[i+1] 
    print("position en adresse : ",startHeaderTable+68*2,"& position byte : ",hex(startHeaderTable+68*2))
    
    #END# 32bit(0x20)/64bit(0x)
    return programHeaderContent