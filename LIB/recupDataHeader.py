from LIB.analyseElf import *
from LIB.displayHeader import display


def recupData():
    HexContent = GetElf("EXECUTABLES/echoOui.elf")
    fildeHeaderContent = FILEHEADER()
    fildeHeaderContent = recupDataFileHeader(fildeHeaderContent,HexContent)    
    
    programHeaderContent = PROGRAMHEADER()
    programHeaderContent = recupDataProgramHeader(programHeaderContent,HexContent)
    
    dataProgramContent = CODEDATA()
    dataProgramContent = recupDataCode(dataProgramContent,HexContent)
    display(fildeHeaderContent,programHeaderContent)
    

def recupDataFileHeader(fileHeaderContent: str,HexContent: str):

    for i in range(0, 8, 2):      # 32bit/64bit(0x00 + 4 bytes)
        fileHeaderContent.e_ident.ei_mag += HexContent[i]+HexContent[i+1]+' '

    for i in range(8, 10):        # 32bit/64bit(0x04 + 1 bytes)
        fileHeaderContent.e_ident.ei_class += HexContent[i]

    for i in range(10, 12):       # 32bit/64bit(0x05 + 1 bytes)
        fileHeaderContent.e_ident.ei_data += HexContent[i]

    for i in range(12, 14):       # 32bit/64bit(0x06 + 1 bytes)
        fileHeaderContent.e_ident.ei_version += HexContent[i]

    for i in range(14, 16):       # 32bit/64bit(0x07 + 1 bytes)
        fileHeaderContent.e_ident.ei_osabi += HexContent[i]

    for i in range(16, 18):       # 32bit/64bit(0x08 + 1 bytes)
        fileHeaderContent.e_ident.ei_abiversion += HexContent[i]

    for i in range(18, 32):       # 32bit/64bit(0x09 + 7 bytes)
        fileHeaderContent.e_ident.ei_pad += HexContent[i]+HexContent[i+1] 

    for i in range(32, 36, 2):    # 32bit/64bit(0x10 + 2 bytes)
        fileHeaderContent.e_type += HexContent[i]+HexContent[i+1]
       # fileHeaderContent.e_type=reverse_a_string_slowly(fileHeaderContent.e_type)
        
    for i in range(36, 40, 2):    # 32bit/64bit(0x12 + 2 bytes)
        fileHeaderContent.e_machine += HexContent[i]+HexContent[i+1] 

    for i in range(40, 48, 2):    # 32bit/64bit(0x14 + 4 bytes)
        fileHeaderContent.e_version += HexContent[i]+HexContent[i+1] 

    #on part de l'idée qu'on est en 64 bits pour l'instant

    for i in range(48, 64, 2):    # 32bit(0x18 + 4 bytes)/64bit(0x18 + 8 bytes)
        fileHeaderContent.e_entry += HexContent[i]+HexContent[i+1] 

    for i in range(64, 80, 2):    # 32bit(0x1C + 4 bytes)/64bit(0x20 + 8 bytes)
        fileHeaderContent.e_phoff += HexContent[i]+HexContent[i+1] 

    for i in range(80, 96, 2):    # 32bit(0x20 + 4 bytes)/64bit(0x28 + 8 bytes)
        fileHeaderContent.e_shoff += HexContent[i]+HexContent[i+1] 

    for i in range(96, 104, 2):    # 32bit(0x24 + 4 bytes)/64bit(0x30 + 4 bytes)
        fileHeaderContent.e_flags += HexContent[i]+HexContent[i+1] 

    for i in range(104, 108, 2):   # 32bit(0x28 + 2 bytes)/64bit(0x34 + 2 bytes)
        fileHeaderContent.e_ehsize += HexContent[i]+HexContent[i+1] 

    for i in range(108, 112, 2):  # 32bit(0x2A + 2 bytes)/64bit(0x36 + 2 bytes)
        fileHeaderContent.e_phentsize += HexContent[i]+HexContent[i+1] 

    for i in range(112, 116, 2):  # 32bit(0x2C + 2 bytes)/64bit(0x38 + 2 bytes)
        fileHeaderContent.e_phnum += HexContent[i]+HexContent[i+1] 

    for i in range(116, 120, 2):  # 32bit(0x2E + 2 bytes)/64bit(0x3A + 2 bytes)
        fileHeaderContent.e_shentsize += HexContent[i]+HexContent[i+1] 

    for i in range(120, 124, 2):  # 32bit(0x30 + 2 bytes)/64bit(0x3C + 2 bytes)
        fileHeaderContent.e_shnum += HexContent[i]+HexContent[i+1] 

    for i in range(124, 128, 2):  # 32bit(0x32 + 2 bytes)/64bit(0x3E + 2 bytes)
        fileHeaderContent.e_shstrndx += HexContent[i]+HexContent[i+1] 
    
    #END# 32bit(0x34)/64bit(0x40)
    return fileHeaderContent

def recupDataProgramHeader(programHeaderContent: str,HexContent: str ):
    #on part encore sur l'idée qu'on est sur du 64 bit
    for i in range(128, 136, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.p_type += HexContent[i]+HexContent[i+1] 
    for i in range(136, 144, 2):      # 64bit(0x04 + 4 bytes)
        programHeaderContent.p_flags += HexContent[i]+HexContent[i+1] 
    for i in range(144, 160, 2):      # 32bit(0x04 + 4 bytes) / 64bit(0x08 + 8 bytes)
        programHeaderContent.p_offset += HexContent[i]+HexContent[i+1] 
    for i in range(160, 176, 2):      # 32bit(0x08 + 4 bytes) / 64bit(0x10 + 8 bytes)
        programHeaderContent.p_vaddr += HexContent[i]+HexContent[i+1] 
    for i in range(176, 192, 2):      # 32bit(0x0c + 4 bytes) / 64bit(0x18 + 8 bytes)
        programHeaderContent.p_paddr += HexContent[i]+HexContent[i+1] 
    for i in range(192, 208, 2):      # 32bit(0x10 + 4 bytes) / 64bit(0x20 + 8 bytes)
        programHeaderContent.p_filesz += HexContent[i]+HexContent[i+1] 
    for i in range(208, 224, 2):      # 32bit(0x14 + 4 bytes) / 64bit(0x28 + 8 bytes)
        programHeaderContent.p_memsz += HexContent[i]+HexContent[i+1] 
    #for i in range(218, 236, 2):      # 32bit(0x18 + 4 bytes) 
    #    programHeaderContent.p_flags += HexContent[i]+HexContent[i+1] 
    for i in range(224, 240, 2):      # 32bit(0x1C + 4 bytes) / 64bit(0x30 + 8 bytes)
        programHeaderContent.p_alin += HexContent[i]+HexContent[i+1] 
    
    #END# 32bit(0x20)/64bit(0x)
    return programHeaderContent

def recupDataCode(programHeaderContent: str,HexContent: str ):
    #on part encore sur l'idée qu'on est sur du 64 bit
    for i in range(234, 236, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.len += HexContent[i]+HexContent[i+1] 
    for i in range(234, 236, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.data += HexContent[i]+HexContent[i+1] 
    for i in range(234, 236, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.write += HexContent[i]+HexContent[i+1] 
    for i in range(3216, 3256, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.rodata += HexContent[i]+HexContent[i+1] 
    return programHeaderContent

def recupDataSectionHeader(programHeaderContent: str,HexContent: str ):
    #on part encore sur l'idée qu'on est sur du 64 bit
    for i in range(121, 129, 2):      # 32bit/64bit(0x00 + 4 bytes)
        programHeaderContent.sh_name += HexContent[i]+HexContent[i+1] 
    for i in range(129, 137, 2):      # 64bit(0x04 + 4 bytes)
        programHeaderContent.sh_type += HexContent[i]+HexContent[i+1] 
    for i in range(138, 154, 2):      # 32bit(0x04 + 4 bytes) / 64bit(0x08 + 8 bytes)
        programHeaderContent.sh_flags += HexContent[i]+HexContent[i+1] 
    for i in range(154, 170, 2):      # 32bit(0x08 + 4 bytes) / 64bit(0x10 + 8 bytes)
        programHeaderContent.sh_addr += HexContent[i]+HexContent[i+1] 
    for i in range(170, 186, 2):      # 32bit(0x0c + 4 bytes) / 6+4bit(0x18 + 8 bytes)
        programHeaderContent.sh_offset += HexContent[i]+HexContent[i+1] 
    for i in range(186, 202, 2):      # 32bit(0x10 + 4 bytes) / 64bit(0x20 + 8 bytes)
        programHeaderContent.sh_size += HexContent[i]+HexContent[i+1] 
    for i in range(202, 218, 2):      # 32bit(0x14 + 4 bytes) / 64bit(0x28 + 8 bytes)
        programHeaderContent.sh_link += HexContent[i]+HexContent[i+1] 
    for i in range(218, 236, 2):      # 32bit(0x18 + 4 bytes) 
        programHeaderContent.sh_info += HexContent[i]+HexContent[i+1] 
    for i in range(218, 234, 2):      # 32bit(0x1C + 4 bytes) / 64bit(0x30 + 8 bytes)
        programHeaderContent.sh_addralign += HexContent[i]+HexContent[i+1] 
    for i in range(218, 234, 2):      # 32bit(0x1C + 4 bytes) / 64bit(0x30 + 8 bytes)
        programHeaderContent.sh_entsize += HexContent[i]+HexContent[i+1] 
    
    #END# 32bit(0x20)/64bit(0x)
    return programHeaderContent