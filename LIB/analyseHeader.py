from LIB.analyseElf import *


class E_IDENT:
    def __init__(self):
        # 0x7F followed by ELF(45 4c 46) in ASCII; these four bytes constitute the magic number.
        self.ei_mag = ""
        # This byte is set to either 1 or 2 to signify 32- or 64-bit format, respectively.
        self.ei_class = ""
        # This byte is set to either 1 or 2 to signify little or big endianness, respectively. This affects interpretation of multi-byte fields starting with offset 0x10.
        self.ei_data = ""
        # Set to 1 for the original and current version of ELF.
        self.ei_version = ""
        # Identifies the target operating system ABI.It is often set to 0 regardless of the target platform.
        self.ei_osabi = ""
        self.ei_abiversion = ""  # This byte identifies the version of the ABI to which the object is targeted. This field is used to distinguish among incompatible versions of an ABI. The interpretation of this version number is dependent on the ABI identified by the EI_OSABI field. Applications conforming to this specification use the value 0.
        self.ei_pad = ""  # Start of padding. These bytes are reserved and set to zero. Programs which read them should ignore them. The value for EI_PAD will change in the future if currently unused bytes are given meanings.

    def display(self):
        self.displayMag()  # print("Magic Number :",self.ei_mag)
        self.displayFormat()  # print("Format :",self.ei_class)
        self.displayEndianness()  # print("Endianness :",self.ei_data)
        print("Version Original du elf :", self.ei_version)
        self.displayOsabi()  # print("Système d'exploitation:",self.ei_osabi)
        print("ei_abiversion = ? :", self.ei_abiversion)
       # print("",self.ei_pad)

    def displayMag(self):
        print("Magic Number :", self.ei_mag, "<>", end=' ')
        if self.ei_mag == '7f 45 4c 46 ':
            print("ELF")

    def displayFormat(self):
        print("Format:", self.ei_class, "<>", end=' ')
        if self.ei_class == '01':
            print("32-bit")
        elif self.ei_class == '02':
            print("64-bit")

    def displayEndianness(self):
        print("Endianness:", self.ei_data, "<>", end=' ')
        if self.ei_data == '01':
            print("(little)")
        elif self.ei_data == '02':
            print("(big)")

    def displayOsabi(self):
        print("Système d'exploitation:", self.ei_osabi, "<>", end=' ')
        if self.ei_osabi == '00':
            print("System V")
        elif self.ei_osabi == '01':
            print("HP-UX")
        elif self.ei_osabi == '02':
            print("NetBSD")
        elif self.ei_osabi == '03':
            print("Linux")
        elif self.ei_osabi == '04':
            print("GNU Hurd")
        elif self.ei_osabi == '06':
            print("Solaris")
        elif self.ei_osabi == '07':
            print("AIX")
        elif self.ei_osabi == '08':
            print("IRIX")
        elif self.ei_osabi == '09':
            print("FreeBSD")
        elif self.ei_osabi == '0A':
            print("Tru64")
        elif self.ei_osabi == '0B':
            print("Novell Modesto")
        elif self.ei_osabi == '0C':
            print("OpenBSD")
        elif self.ei_osabi == '0D':
            print("OpenVMS")
        elif self.ei_osabi == '0E':
            print("NonStop Kernel")
        elif self.ei_osabi == '0F':
            print("AROS")
        elif self.ei_osabi == '10':
            print("Fenix OS")
        elif self.ei_osabi == '11':
            print("CloudABI")
        elif self.ei_osabi == '12':
            print("Stratus Technologies OpenVos")


class FILEHEADER:
    def __init__(self):
        self.e_ident = E_IDENT()
        self.e_type = ""  # Identifies object file type.
        self.e_machine = ""  # Specifies target instruction set architecture.
        self.e_version = ""  # Set to 1 for the original version of ELF.
        # This is the memory address of the entry point from where the process starts executing. This field is either 32 or 64 bits long depending on the format defined earlier.
        self.e_entry = ""
        # Points to the start of the program header table. It usually follows the file header immediately, making the offset 0x34 or 0x40 for 32- and 64-bit ELF executables, respectively.
        self.e_phoff = ""
        self.e_shoff = ""  # Points to the start of the section header table.
        # Interpretation of this field depends on the target architecture.
        self.e_flags = ""
        # Contains the size of this header, normally 64 Bytes for 64-bit and 52 Bytes for 32-bit format.
        self.e_ehsize = ""
        # Contains the size of a program header table entry.
        self.e_phentsize = ""
        # Contains the number of entries in the program header table.
        self.e_phnum = ""
        # Contains the size of a section header table entry.
        self.e_shentsize = ""
        # Contains the number of entries in the section header table.
        self.e_shnum = ""
        # Contains index of the section header table entry that contains the section names.
        self.e_shstrndx = ""

    def display(self):
        self.displayType()  # print("Type de fichier :", self.e_type)
        self.displayMachine()  # print("Type d'architecture  :", self.e_machine)
        print("Version du ELF :", self.e_version)
        print("Adresse de 'entry point' :", self.e_entry)
        print("Adresse de du début du programme 'header table'", self.e_phoff)
        print("Addresse de la section 'header table'", self.e_shoff)
        print("ei_flag = ? :", self.e_flags)
        print("Taille de son header :", self.e_ehsize)
        print("Taille du 'program header table entry':", self.e_phentsize)
        print("Nombre d'entrée dans le 'header table' :", self.e_phnum)
        print("Taille de la 'section header table entry'", self.e_shentsize)
        print("Nombre d'entrée dans la 'section header table' :", self.e_shnum)
        print("index de l'entrée de table du header de la section qui contient les noms de section :", self.e_shstrndx)

    def displayType(self):
        print("Type de fichier :", self.e_type, "<>", end=' ')
        if self.e_type == '00 00 ':
            print("ET_NONE")
        elif self.e_type == '00 01 ':
            print("ET_REL")
        elif self.e_type == '00 02 ':
            print("ET_EXEC")
        elif self.e_type == '00 03 ':
            print("ET_DYN")
        elif self.e_type == '00 04 ':
            print("ET_CORE")
        elif self.e_type == 'fe 00 ':
            print("ET_LOOS")
        elif self.e_type == 'fe ff ':
            print("ET_HIOS")
        elif self.e_type == 'ff 00 ':
            print("ET_LOPROC")
        elif self.e_type == 'ff ff ':
            print("ET_HIPROC")

    def displayMachine(self):
        print("Type d'architecture :", self.e_machine, "<>", end=' ')
        if self.e_machine == '00 00 ':
            print("")
        elif self.e_machine == '00 02 ':
            print("SPARC")
        elif self.e_machine == '00 03 ':
            print("x86")
        elif self.e_machine == '00 08 ':
            print("MIPS")
        elif self.e_machine == '00 14 ':
            print("PowerPC")
        elif self.e_machine == '00 16 ':
            print("S390")
        elif self.e_machine == '00 28 ':
            print("ARM")
        elif self.e_machine == '00 2A ':
            print("SuperH")
        elif self.e_machine == '00 32 ':
            print("IA-64")
        elif self.e_machine == '00 3E ':
            print("amd64")
        elif self.e_machine == '00 B7 ':
            print("AArch64")
        elif self.e_machine == '00 F3 ':
            print("RISC-V")

#Récupération de la chaine Hexadecimal du ELF


def recupData():
    HexContent = GetElf("EXECUTABLES/echoOui.elf")
    filderHeaderContent = FILEHEADER()
    for i in range(0, 8, 2):  # 32bit/64bit(0x00 + 4 bytes)
        filderHeaderContent.e_ident.ei_mag += HexContent[i]+HexContent[i+1]+' '

    for i in range(8, 10):  # 32bit/64bit(0x04 + 1 bytes)
        filderHeaderContent.e_ident.ei_class += HexContent[i]

    for i in range(10, 12):  # 32bit/64bit(0x05 + 1 bytes)
        filderHeaderContent.e_ident.ei_data += HexContent[i]

    for i in range(12, 14):  # 32bit/64bit(0x06 + 1 bytes)
        filderHeaderContent.e_ident.ei_version += HexContent[i]

    for i in range(14, 16):  # 32bit/64bit(0x07 + 1 bytes)
        filderHeaderContent.e_ident.ei_osabi += HexContent[i]

    for i in range(16, 18):   # 32bit/64bit(0x08 + 1 bytes)
        filderHeaderContent.e_ident.ei_abiversion += HexContent[i]

    for i in range(18, 25):   # 32bit/64bit(0x09 + 7 bytes)
        filderHeaderContent.e_ident.ei_pad += HexContent[i]+HexContent[i+1]+' '

    for i in range(25, 29, 2):# 32bit/64bit(0x10 + 2 bytes)
        filderHeaderContent.e_type += HexContent[i]+HexContent[i+1]+' '

    for i in range(29, 33, 2):  # 32bit/64bit(0x12 + 2 bytes)
        filderHeaderContent.e_machine += HexContent[i]+HexContent[i+1]+' '

    for i in range(33, 41, 2):  # 32bit/64bit(0x14 + 4 bytes)
        filderHeaderContent.e_version += HexContent[i]+HexContent[i+1]+' '
#on part de l'idée qu'on est en 64 bits pour l'instant
    for i in range(41, 57, 2):  # 32bit(0x18 + 4 bytes)/64bit(0x18 + 8 bytes)
        filderHeaderContent.e_entry += HexContent[i]+HexContent[i+1]+' '

    for i in range(57, 73, 2):  # 32bit(0x1C + 4 bytes)/64bit(0x20 + 8 bytes)
        filderHeaderContent.e_phoff += HexContent[i]+HexContent[i+1]+' '

    for i in range(73, 89, 2):  # 32bit(0x20 + 4 bytes)/64bit(0x28 + 8 bytes)
        filderHeaderContent.e_shoff += HexContent[i]+HexContent[i+1]+' '

    for i in range(89, 97, 2):  # 32bit(0x24 + 4 bytes)/64bit(0x30 + 4 bytes)
        filderHeaderContent.e_flags += HexContent[i]+HexContent[i+1]+' '

    for i in range(97, 101, 2):  # 32bit(0x28 + 2 bytes)/64bit(0x34 + 2 bytes)
        filderHeaderContent.e_ehsize += HexContent[i]+HexContent[i+1]+' '

    for i in range(101, 105, 2):  # 32bit(0x2A + 2 bytes)/64bit(0x36 + 2 bytes)
        filderHeaderContent.e_phentsize += HexContent[i]+HexContent[i+1]+' '
   
    for i in range(105, 109, 2):  # 32bit(0x2C + 2 bytes)/64bit(0x38 + 2 bytes)
        filderHeaderContent.e_phnum += HexContent[i]+HexContent[i+1]+' '
   
    for i in range(109, 113, 2):  # 32bit(0x2E + 2 bytes)/64bit(0x3A + 2 bytes)
        filderHeaderContent.e_shentsize += HexContent[i]+HexContent[i+1]+' '
   
    for i in range(113, 117, 2):  # 32bit(0x30 + 2 bytes)/64bit(0x3C + 2 bytes)
        filderHeaderContent.e_shnum += HexContent[i]+HexContent[i+1]+' '
   
    for i in range(117, 121, 2):  # 32bit(0x32 + 2 bytes)/64bit(0x3E + 2 bytes)
        filderHeaderContent.e_shstrndx += HexContent[i]+HexContent[i+1]+' '
   
   #END# for i in range(41, 57, 2):  # 32bit(0x34 + 2 bytes)/64bit(0x40 + 2 bytes)
   #END#    filderHeaderContent.e_ehsize += HexContent[i]+HexContent[i+1]+' '
    filderHeaderContent.display()
    #filderHeaderContent.e_ident.displayMag()
    #display(filderHeaderContent)


def display(filderHeaderContent: str):

    filderHeaderContent.display()


def tata():

    HexContent = GetElf("EXECUTABLES/echoOui.elf")
    #print(HexContent)

    #print(len(HexContent))
    #Extraire le File Header du ELF

    #1 Byte = 8 bit = deux caracatere hex et un Byte = octet = 8 bit
    # et un Byte n'est pas tout le temps 8 bits par contre 1 octet = 8bit

    #Magic Number ELF 4 byte
    print("Magic Number")
    for i in range(0, 4):
       # print(HexContent[i],HexContent[i+1], sep='separator', end=" coucou")
        print(HexContent[i])

    #Format de l'elf 0 pour 32 bit et 2 pour 64 bit
    print()
    print("Format")
    for i in range(8, 10):
        print(HexContent[i], end=" ")

    print()
    print("Endianness")
    for i in range(10, 12):
        print(HexContent[i], end=" ")

    print()
    #1 signigie que c'est la version original du elf
    print("Version Original du elf")
    for i in range(12, 14):
        print(HexContent[i], end=" ")

    print()
    #Systeme d'exploitation cible 0x00	Système V 0x01	HP-UX 0x02	NetBSD 0x03	Linux 0x04	GNU Hurd 0x06	Solaris 0x07	AIX 0x08	IRIX 0x09	FreeBSD 0x0A	Tru64 0x0B	Novell Modesto 0x0C	OpenBSD 0x0D	OpenVMS 0x0E	NonStop Kernel 0x0F	AROS 0x10	Fenix ​​OS 0x11	CloudABI
    print("Systeme d'exploitation du ELF : ")
    for i in range(14, 16):
        print(HexContent[i], end=" ")

    print()
    print("ABI Version")
    for i in range(16, 18):
        print(HexContent[i], end=" ")

    print()
    #espace pas utilisé
    print("Pas utilisé :")
    for i in range(18, 32):
        print(HexContent[i], end=" ")

    print()
    #Object Type File
    print("Object Type File : ")
    for i in range(32, 36):
        print(HexContent[i], end=" ")

    print()
    #intructuion set architecture
    print("Architecture :")
    for i in range(36, 40):
        print(HexContent[i], end=" ")

    print()
    #Version (1 = original version)
    print("Version : ")
    for i in range(40, 48):
        print(HexContent[i], end=" ")

    print()
    #Entry point execution du code
    print("Entry Point : ")
    for i in range(48, 66):
        print(HexContent[i], end=" ")

    print()
    #Entry p off (entry point du header table)
    print("Entry Point Header Table : ")
    for i in range(66, 82):
        print(HexContent[i], end=" ")

    print()
    #Entry Point de la section
    print("Entry Point Section : ")
    for i in range(82, 98):
        print(HexContent[i], end=" ")

    print()
    #e_flags
    print("FLag : ")
    for i in range(98, 106):
        print(HexContent[i], end=" ")

    print()
    #e_ehsize
    print("E Size: ")
    for i in range(106, 110):
        print(HexContent[i], end=" ")

    print()
    #e_phentsize
    print("e_phentsize: ")
    for i in range(110, 114):
        print(HexContent[i], end=" ")

    print()
    #e_phnum
    print("e_phentsize: ")
    for i in range(110, 114):
        print(HexContent[i], end=" ")

    print()
    #e_hentsize
    print("e_phentsize: ")
    for i in range(114, 118):
        print(HexContent[i], end=" ")

    print()
    #e_shnum
    print("e_shnum: ")
    for i in range(118, 122):
        print(HexContent[i], end=" ")

    print()
    #e_shstrndx
    print("e_shstrndx: ")
    for i in range(122, 126):
        print(HexContent[i], end=" ")

    #	End of ELF Header (size)   #

    #P type type of segement
    print()
    print("p_type : ")
    for i in range(126, 134):
        print(HexContent[i], end=" ")

    #Flag segement
    print()
    print("p_flag : ")
    for i in range(134, 142):
        print(HexContent[i], end=" ")

    #Extraire le programme Header Table

    #Extraire les sections du ELF

    #Extraire Section Header Table du ELF
