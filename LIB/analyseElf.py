#Class nécessaires
class E_IDENT:
    def __init__(self):
        # 0x7F followed by ELF(45 4c 46) in ASCII; these four bytes constitute the magic number.
        self.ei_mag = ""
        # This byte is set to either 1 or 2 to signify 32- or 64-bit format, respectively.
        self.ei_class = ""
        # This byte is set to either 1 or 2 to signify little or big endianness, respectively. This affects interpretation of multi-byte fields starting with offset 0x10.
        self.ei_data = ""
        # Set to 1 for the original and current version of ELF.
        self.ei_version = ""
        # Identifies the target operating system ABI.It is often set to 0 regardless of the target platform.
        self.ei_osabi = ""
        # This byte identifies the version of the ABI to which the object is targeted. This field is used to distinguish among incompatible versions of an ABI. The interpretation of this version number is dependent on the ABI identified by the EI_OSABI field. Applications conforming to this specification use the value 0.
        self.ei_abiversion = ""
        # Start of padding. These bytes are reserved and set to zero. Programs which read them should ignore them. The value for EI_PAD will change in the future if currently unused bytes are given meanings.
        self.ei_pad = ""

    def display(self):
        self.displayMag()
        self.displayFormat()
        self.displayEndianness()
        print("Version Original du elf :", self.ei_version)
        self.displayOsabi()
        print("ei_abiversion = ? :", self.ei_abiversion)
       # print("",self.ei_pad)

    def displayMag(self):
        print("Magic Number :", self.ei_mag, "<>", end=' ')
        if self.ei_mag == '7f 45 4c 46 ':
            print("ELF")

    def displayFormat(self):
        print("Format:", self.ei_class, "<>", end=' ')
        if self.ei_class == '01':
            print("32-bit")
        elif self.ei_class == '02':
            print("64-bit")

    def displayEndianness(self):
        print("Endianness:", self.ei_data, "<>", end=' ')
        if self.ei_data == '01':
            print("(little)")
        elif self.ei_data == '02':
            print("(big)")

    def displayOsabi(self):
        print("Système d'exploitation:", self.ei_osabi, "<>", end=' ')
        if self.ei_osabi == '00':
            print("System V")
        elif self.ei_osabi == '01':
            print("HP-UX")
        elif self.ei_osabi == '02':
            print("NetBSD")
        elif self.ei_osabi == '03':
            print("Linux")
        elif self.ei_osabi == '04':
            print("GNU Hurd")
        elif self.ei_osabi == '06':
            print("Solaris")
        elif self.ei_osabi == '07':
            print("AIX")
        elif self.ei_osabi == '08':
            print("IRIX")
        elif self.ei_osabi == '09':
            print("FreeBSD")
        elif self.ei_osabi == '0A':
            print("Tru64")
        elif self.ei_osabi == '0B':
            print("Novell Modesto")
        elif self.ei_osabi == '0C':
            print("OpenBSD")
        elif self.ei_osabi == '0D':
            print("OpenVMS")
        elif self.ei_osabi == '0E':
            print("NonStop Kernel")
        elif self.ei_osabi == '0F':
            print("AROS")
        elif self.ei_osabi == '10':
            print("Fenix OS")
        elif self.ei_osabi == '11':
            print("CloudABI")
        elif self.ei_osabi == '12':
            print("Stratus Technologies OpenVos")

class FILEHEADER:
    def __init__(self):
        self.e_ident = E_IDENT()
        # Identifies object file type.
        self.e_type = ""
        # Specifies target instruction set architecture.
        self.e_machine = ""
        # Set to 1 for the original version of ELF.
        self.e_version = ""
        # This is the memory address of the entry point from where the process starts executing. This field is either 32 or 64 bits long depending on the format defined earlier.
        self.e_entry = ""
        # Points to the start of the program header table. It usually follows the file header immediately, making the offset 0x34 or 0x40 for 32- and 64-bit ELF executables, respectively.
        self.e_phoff = ""
        # Points to the start of the section header table.
        self.e_shoff = ""
        # Interpretation of this field depends on the target architecture.
        self.e_flags = ""
        # Contains the size of this header, normally 64 Bytes for 64-bit and 52 Bytes for 32-bit format.
        self.e_ehsize = ""
        # Contains the size of a program header table entry.
        self.e_phentsize = ""
        # Contains the number of entries in the program header table.
        self.e_phnum = ""
        # Contains the size of a section header table entry.
        self.e_shentsize = ""
        # Contains the number of entries in the section header table.
        self.e_shnum = ""
        # Contains index of the section header table entry that contains the section names.
        self.e_shstrndx = ""

    def display(self):
        print("---------------------File Header---------------------")
        self.displayType()
        self.displayMachine()
        print("Version du ELF :", self.e_version)
        print("Adresse de 'entry point' :", self.e_entry)
        print("Adresse de du début du programme 'header table'", self.e_phoff)
        print("Addresse de la section 'header table'", self.e_shoff)
        print("ei_flag = ? :", self.e_flags)
        print("Taille de son header :", self.e_ehsize)
        print("Taille du 'program header table entry':", self.e_phentsize)
        print("Nombre d'entrée dans le 'header table' :", self.e_phnum)
        print("Taille de la 'section header table entry'", self.e_shentsize)
        print("Nombre d'entrée dans la 'section header table' :", self.e_shnum)
        print("index de l'entrée de table du header de la section qui contient les noms de section :", self.e_shstrndx)

    def displayType(self):
        print("Type de fichier :", self.e_type, "<>", end=' ')
        if self.e_type == '00 00 ':
            print("ET_NONE")
        elif self.e_type == '00 01 ':
            print("ET_REL")
        elif self.e_type == '00 02 ':
            print("ET_EXEC")
        elif self.e_type == '00 03 ':
            print("ET_DYN")
        elif self.e_type == '00 04 ':
            print("ET_CORE")
        elif self.e_type == 'fe 00 ':
            print("ET_LOOS")
        elif self.e_type == 'fe ff ':
            print("ET_HIOS")
        elif self.e_type == 'ff 00 ':
            print("ET_LOPROC")
        elif self.e_type == 'ff ff ':
            print("ET_HIPROC")

    def displayMachine(self):
        print("Type d'architecture :", self.e_machine, "<>", end=' ')
        if self.e_machine == '00 00 ':
            print("")
        elif self.e_machine == '00 02 ':
            print("SPARC")
        elif self.e_machine == '00 03 ':
            print("x86")
        elif self.e_machine == '00 08 ':
            print("MIPS")
        elif self.e_machine == '00 14 ':
            print("PowerPC")
        elif self.e_machine == '00 16 ':
            print("S390")
        elif self.e_machine == '00 28 ':
            print("ARM")
        elif self.e_machine == '00 2A ':
            print("SuperH")
        elif self.e_machine == '00 32 ':
            print("IA-64")
        elif self.e_machine == '00 3E ':
            print("amd64")
        elif self.e_machine == '00 B7 ':
            print("AArch64")
        elif self.e_machine == '00 F3 ':
            print("RISC-V")
    
class PROGRAMHEADER:
    def __init__(self):
        # Identifies the type of the segment
        self.p_type = ""    
        # Segment-Dependent flags ( position for 64-bit structure )
        self.p_flags = "" 
        # Offset of the segment in the file image
        self.p_offset = "" 
        # Virtual address of the segment in memory
        self.p_vaddr = "" 
        # On systems where physical address is relevant, reserve for segment's physical address
        self.p_paddr = "" 
        # Size in bytes of the segment in the file image. May be 0
        self.p_filesz = "" 
        # Size in bytes of the sement in memory. May be 0
        self.p_memsz = "" 
        # Segment-edpendent flags (position for 32-bit structure)
        self.p_flags = "" 
        #0 and 1 specify no alignment. Otherwize should be a positive, integral power of 2k with p_vaddr equatin p_offset modulus p_align
        self.p_alin = ""    

    def display(self):
        print("---------------------Program Header---------------------")
        self.displayType()
        print("p_flags :", self.p_flags)
        print("p_offset :", self.p_offset)
        print("p_vaddr :", self.p_vaddr)
        print("p_paddr :", self.p_paddr)
        print("p_filesz :", self.p_filesz)
        print("p_memsz :", self.p_memsz)
        print("p_flags :", self.p_flags)
        print("p_alin :", self.p_alin)

    def displayType(self):
        print("p_type :", self.p_type,"<>", end=' ')
        if self.p_flags == '00 00 00 00':
            print("PT_NULL <> Program header table entry unused")
        elif self.p_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.p_flags == '00 00 00 02 ':
            print("PT_DYNAMIC <> Dynamic linking information")
        elif self.p_flags == '00 00 00 03 ':
            print("PT_INTERP <> Interpreter information")
        elif self.p_flags == '00 00 00 04 ':
            print("PT_NOTE <> Auxillary information")
        elif self.p_flags == '00 00 00 05 ':
            print("PT_SHLIB <> Reserved")
        elif self.p_flags == '00 00 00 06 ':
            print("PT_PHDR <> Segment containing program header table itself")
        elif self.p_flags == '00 00 00 07 ':
            print("PT_TLS <> Thread-Local Storage template")
        elif self.p_flags == '60 00 00 00 ':
            print("PT_LOOS <> inclusive reserver ranges for operating system (processor) specific semantics")
        elif self.p_flags == '6F FF FF FF ':
            print("PT_HIOS <> inclusive reserver ranges for operating system (processor) specific semantics")
        elif self.p_flags == '70 00 00 00 ':
            print("PT_LOPROC <> inclusive reserver ranges for operating system (processor) specific semantics")
        elif self.p_flags == '7F FF FF FF ':
            print("PT_HIPROC <> inclusive reserver ranges for operating system (processor) specific semantics")
        else:
            print("")

#Récupération de la chaine Hexadecimal du ELF
def GetElf(input_file: str):
    with open(input_file, mode='rb') as file:
        return file.read().hex()

