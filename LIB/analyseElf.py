#Class nécessaires


def reverseBinaryCode(str):
    returnString = ''
    i = len(str)
    while i:
        i -= 2                  # index = index - 1
        returnString += str[i]+str[i+1] # new_string = new_string + character
    return returnString


class E_IDENT:
    def __init__(self):
        # 0x7F followed by ELF(45 4c 46) in ASCII; these four bytes constitute the magic number.
        self.ei_mag = ""
        # This byte is set to either 1 or 2 to signify 32- or 64-bit format, respectively.
        self.ei_class = ""
        # This byte is set to either 1 or 2 to signify little or big endianness, respectively. This affects interpretation of multi-byte fields starting with offset 0x10.
        self.ei_data = ""
        # Set to 1 for the original and current version of ELF.
        self.ei_version = ""
        # Identifies the target operating system ABI.It is often set to 0 regardless of the target platform.
        self.ei_osabi = ""
        # This byte identifies the version of the ABI to which the object is targeted. This field is used to distinguish among incompatible versions of an ABI. The interpretation of this version number is dependent on the ABI identified by the EI_OSABI field. Applications conforming to this specification use the value 0.
        self.ei_abiversion = ""
        # Start of padding. These bytes are reserved and set to zero. Programs which read them should ignore them. The value for EI_PAD will change in the future if currently unused bytes are given meanings.
        self.ei_pad = ""

    def display(self):
        print("---------------------E_Ident---------------------")
        self.displayMag()
        self.displayFormat()
        self.displayEndianness()
        self.ei_version="0x"+self.ei_version;print("Version Original du elf :", self.ei_version)
        self.displayOsabi()
        self.ei_abiversion="0x"+self.ei_abiversion;print("ei_abiversion:", self.ei_abiversion)
       # print("",self.ei_pad)

    def displayMag(self):
        print("Magic Number :", self.ei_mag, "<>", end=' ')
        if self.ei_mag == '7f 45 4c 46 ':
            print("ELF")
        else:
            print("")

    def displayFormat(self):
        self.ei_class="0x"+self.ei_class;print("Format:", self.ei_class, "<>", end=' ')
        if self.ei_class == '0x01':
            print("32-bit")
        elif self.ei_class == '0x02':
            print("64-bit")
        else:
            print("")

    def displayEndianness(self):
        self.ei_data="0x"+self.ei_data;print("Endianness:", self.ei_data, "<>", end=' ')
        if self.ei_data == '0x01':
            print("(little)")
        elif self.ei_data == '0x02':
            print("(big)")
        else:
            print("")

    def displayOsabi(self):
        self.ei_osabi="0x"+self.ei_osabi;print("Système d'exploitation:", self.ei_osabi, "<>", end=' ')
        if self.ei_osabi == '0x00':
            print("System V")
        elif self.ei_osabi == '0x01':
            print("HP-UX")
        elif self.ei_osabi == '0x02':
            print("NetBSD")
        elif self.ei_osabi == '0x03':
            print("Linux")
        elif self.ei_osabi == '0x04':
            print("GNU Hurd")
        elif self.ei_osabi == '0x06':
            print("Solaris")
        elif self.ei_osabi == '0x07':
            print("AIX")
        elif self.ei_osabi == '0x08':
            print("IRIX")
        elif self.ei_osabi == '0x09':
            print("FreeBSD")
        elif self.ei_osabi == '0x0A':
            print("Tru64")
        elif self.ei_osabi == '0x0B':
            print("Novell Modesto")
        elif self.ei_osabi == '0x0C':
            print("OpenBSD")
        elif self.ei_osabi == '0x0D':
            print("OpenVMS")
        elif self.ei_osabi == '0x0E':
            print("NonStop Kernel")
        elif self.ei_osabi == '0x0F':
            print("AROS")
        elif self.ei_osabi == '0x10':
            print("Fenix OS")
        elif self.ei_osabi == '0x11':
            print("CloudABI")
        elif self.ei_osabi == '0x12':
            print("Stratus Technologies OpenVos")
        else:
            print("")

class FILEHEADER:
    def __init__(self):
        self.e_ident = E_IDENT()
        # Identifies object file type.
        self.e_type = ""
        # Specifies target instruction set architecture.
        self.e_machine = ""
        # Set to 1 for the original version of ELF.
        self.e_version = ""
        # This is the memory address of the entry point from where the process starts executing. This field is either 32 or 64 bits long depending on the format defined earlier.
        self.e_entry = ""
        # Points to the start of the program header table. It usually follows the file header immediately, making the offset 0x34 or 0x40 for 32- and 64-bit ELF executables, respectively.
        self.e_phoff = ""
        # Points to the start of the section header table.
        self.e_shoff = ""
        # Interpretation of this field depends on the target architecture.
        self.e_flags = ""
        # Contains the size of this header, normally 64 Bytes for 64-bit and 52 Bytes for 32-bit format.
        self.e_ehsize = ""
        # Contains the size of a program header table entry.
        self.e_phentsize = ""
        # Contains the number of entries in the program header table.
        self.e_phnum = ""
        # Contains the size of a section header table entry.
        self.e_shentsize = ""
        # Contains the number of entries in the section header table.
        self.e_shnum = ""
        # Contains index of the section header table entry that contains the section names.
        self.e_shstrndx = ""

    def display(self):
        print("---------------------File Header---------------------")
        self.displayType()
        self.displayMachine()
        self.e_version="0x"+reverseBinaryCode(self.e_version);print("Version du ELF :", self.e_version)
        self.e_entry="0x"+reverseBinaryCode(self.e_entry);print("Adresse de 'entry point' :", self.e_entry)
        self.e_phoff="0x"+reverseBinaryCode(self.e_phoff);print("Adresse de du début du programme 'header table'", self.e_phoff)
        self.e_shoff="0x"+reverseBinaryCode(self.e_shoff);print("Addresse de la section 'header table'", self.e_shoff)
        self.e_flags="0x"+reverseBinaryCode(self.e_flags);print("ei_flag :", self.e_flags)
        self.e_ehsize="0x"+reverseBinaryCode(self.e_ehsize);print("Taille de son header :", self.e_ehsize)
        self.e_phentsize="0x"+reverseBinaryCode(self.e_phentsize);print("Taille du 'program header table entry':", self.e_phentsize)
        self.e_phnum="0x"+reverseBinaryCode(self.e_phnum);print("Nombre d'entrée dans le 'header table' :", self.e_phnum)
        self.e_shentsize="0x"+reverseBinaryCode(self.e_shentsize);print("Taille de la 'section header table entry'", self.e_shentsize)
        self.e_shnum="0x"+reverseBinaryCode(self.e_shnum);print("Nombre d'entrée dans la 'section header table' :", self.e_shnum)
        self.e_shstrndx="0x"+reverseBinaryCode(self.e_shstrndx);print("index de l'entrée de table du header de la section qui contient les noms de section :", self.e_shstrndx)

    def displayType(self):
        self.e_type="0x"+reverseBinaryCode(self.e_type);print("Type de fichier : ",self.e_type, " <> ", end=' ')
        if self.e_type == '0x0000':
            print("ET_NONE")
        elif self.e_type == '0x0001':
            print("ET_REL")
        elif self.e_type == '0x0002':
            print("ET_EXEC")
        elif self.e_type == '0x0003':
            print("ET_DYN")
        elif self.e_type == '0x0004':
            print("ET_CORE")
        elif self.e_type == '0xfe00':
            print("ET_LOOS")
        elif self.e_type == '0xfeff':
            print("ET_HIOS")
        elif self.e_type == '0xff00':
            print("ET_LOPROC")
        elif self.e_type == '0xffff':
            print("ET_HIPROC")
        else:
            print("")
            
    def displayMachine(self):
        self.e_machine="0x"+reverseBinaryCode(self.e_machine);print("Type d'architecture :", self.e_machine, "<>", end=' ')
        if self.e_machine == '0x0000':
            print("")
        elif self.e_machine == '0x0002':
            print("SPARC")
        elif self.e_machine == '0x0003':
            print("x86")
        elif self.e_machine == '0x0008':
            print("MIPS")
        elif self.e_machine == '0x0014':
            print("PowerPC")
        elif self.e_machine == '0x0016':
            print("S390")
        elif self.e_machine == '0x0028':
            print("ARM")
        elif self.e_machine == '0x002a':
            print("SuperH")
        elif self.e_machine == '0x0032':
            print("IA-64")
        elif self.e_machine == '0x003e':
            print("amd64")
        elif self.e_machine == '0x00b7':
            print("AArch64")
        elif self.e_machine == '0x00f3':
            print("RISC-V")
        else:
            print("")
            
class PROGRAMHEADER:
    def __init__(self):
        # Identifies the type of the segment
        self.p_type = ""    
        # Segment-Dependent flags ( position for 64-bit structure )
        self.p_flags = "" 
        # Offset of the segment in the file image
        self.p_offset = "" 
        # Virtual address of the segment in memory
        self.p_vaddr = "" 
        # On systems where physical address is relevant, reserve for segment's physical address
        self.p_paddr = "" 
        # Size in bytes of the segment in the file image. May be 0
        self.p_filesz = "" 
        # Size in bytes of the sement in memory. May be 0
        self.p_memsz = "" 
        # Segment-edpendent flags (position for 32-bit structure)
        # self.p_flags = "" 
        #0 and 1 specify no alignment. Otherwize should be a positive, integral power of 2k with p_vaddr equatin p_offset modulus p_align
        self.p_alin = ""    

    def display(self):
        print("---------------------Program Header---------------------")
        self.displayType()
        self.p_flags="0x"+reverseBinaryCode(self.p_flags);print("p_flags :", self.p_flags)
        self.p_offset="0x"+reverseBinaryCode(self.p_offset);print("p_offset :", self.p_offset)
        self.p_vaddr="0x"+reverseBinaryCode(self.p_vaddr);print("p_vaddr :", self.p_vaddr)
        self.p_paddr="0x"+reverseBinaryCode(self.p_paddr);print("p_paddr :", self.p_paddr)
        self.p_filesz="0x"+reverseBinaryCode(self.p_filesz);print("p_filesz :", self.p_filesz)
        self.p_memsz="0x"+reverseBinaryCode(self.p_memsz);print("p_memsz :", self.p_memsz)
        self.p_alin="0x"+reverseBinaryCode(self.p_alin);print("p_alin :", self.p_alin)

    def displayType(self):
        self.p_type="0x"+reverseBinaryCode(self.p_type);print("p_type :", self.p_type,"<>", end=' ')
        if self.p_type == '0x00000000':
            print("PT_NULL <> Program header table entry unused")
        elif self.p_type == '0x00000001':
            print("PT_LOAD <> Lodable segment")
        elif self.p_type == '0x00000002':
            print("PT_DYNAMIC <> Dynamic linking information")
        elif self.p_type == '0x00000003':
            print("PT_INTERP <> Interpreter information")
        elif self.p_type == '0x00000004':
            print("PT_NOTE <> Auxillary information")
        elif self.p_type == '0x00000005':
            print("PT_SHLIB <> Reserved")
        elif self.p_type == '0x00000006':
            print("PT_PHDR <> Segment containing program header table itself")
        elif self.p_type == '0x00000007':
            print("PT_TLS <> Thread-Local Storage template")
        elif self.p_type == '0x60000000':
            print("PT_LOOS <> inclusive reserver ranges for operating system (processor) specific semantics")
        elif self.p_type == '0x6fffffff':
            print("PT_HIOS <> inclusive reserver ranges for operating system (processor) specific semantics")
        elif self.p_type == '0x70000000':
            print("PT_LOPROC <> inclusive reserver ranges for operating system (processor) specific semantics")
        elif self.p_type == '0x7fffffff':
            print("PT_HIPROC <> inclusive reserver ranges for operating system (processor) specific semantics")
        else:
            print("")

class SECTIONHEADER:
    def __init__(self):
        # An offset to a string in the .shstrtab section that represents the name of this section
        self.sh_name = ""           
        # Identifies the type of this header.
        self.sh_type = ""    
        # Identifies the attributes of the section.
        self.sh_flags = "" 
        # Virtual address of the section in memory, for sections that are loaded.
        self.sh_addr = "" 
        # Offset of the section in the file image.
        self.sh_offset = "" 
        # Size in bytes of the section in the file image. May be 0.
        self.sh_size = "" 
        # Contains the section index of an associated section. This field is used for several purposes, depending on the type of section.
        self.sh_link = "" 
        # Contains extra information about the section. This field is used for several purposes, depending on the type of section.
        self.sh_info = "" 
        # Contains the required alignment of the section. This field must be a power of two.
        self.sh_addralign = "" 
        # Contains the size, in bytes, of each entry, for sections that contain fixed-size entries. Otherwise, this field contains zero.
        self.sh_entsize = ""    

    def display(self):
        print("---------------------Program Header---------------------")
        print("sh_name :", self.sh_name)
        self.displayType()
        self.displayFlags()
        print("sh_addr :", self.sh_addr)
        print("sh_offset :", self.sh_offset)
        print("sh_size :", self.sh_size)
        print("sh_link :", self.sh_link)
        print("sh_info :", self.sh_info)        
        print("sh_addralign :", self.sh_addralign)
        print("sh_entsize :", self.sh_entsize)

    def displayType(self):
        print("sh_type :", self.sh_type,"<>", end=' ')
        if self.sh_type == '00 00 00 00 ':
            print("SHT_NULL <> Section header table entry unused")
        elif self.sh_type == '00 00 00 01 ':
            print("SHT_PROGBITS <> Program data")        
        elif self.sh_type == '00 00 00 02 ':
            print("SHT_SYMTAB   <> Symbol table")
        elif self.sh_type == '00 00 00 03 ':
            print("SHT_STRTAB   <> String table")
        elif self.sh_type == '00 00 00 04 ':
            print("SHT_RELA		<> Relocation entries with addends")
        elif self.sh_type == '00 00 00 05 ':
            print("SHT_HASH	 <> Symbol hash table")
        elif self.sh_type == '00 00 00 06 ':
            print("SHT_DYNAMIC	 <> Dynamic linking information")
        elif self.sh_type == '00 00 00 07 ':
            print("SHT_NOTE	 <> Notes")
        elif self.sh_type == '00 00 00 08 ':
            print("SHT_NOBITS	 <> Program space with no data (bss)")
        elif self.sh_type == '00 00 00 09 ':
            print("SHT_REL	 <> Relocation entries, no addends")
        elif self.sh_type == '00 00 00 0A ':
            print("SHT_REL	 <> Reserved")
        elif self.sh_type == '00 00 00 0B ':
            print("SHT_SHLIB	 <> Dynamic linker symbol table")
        elif self.sh_type == '00 00 00 0E ':
            print("SHT_DYNSYM	 <> Array of constructors")
        elif self.sh_type == '00 00 00 0F ':
            print("SHT_INIT_ARRAY	 <> Array of destructors")
        elif self.sh_type == '00 00 00 10 ':
            print("SHT_FINI_ARRAY	 <> Array of pre-constructors")
        elif self.sh_type == '00 00 00 11 ':
            print("SHT_PREINIT_ARRAY	 <> Section group ")
        elif self.sh_type == '00 00 00 12 ':
            print("SHT_SYMTAB_SHNDX	 <> Extended section indices ")
        elif self.sh_type == '00 00 00 13 ':
            print("SHT_NUM	 <> Number of defined types.")
        elif self.sh_type == '60 00 00 00 ':
            print("SHT_LOOS	 <> Start OS-specific.")
        else:
            print("")

    def displayType(self):
        print("sh_flags :", self.sh_flags,"<>", end=' ')
        if self.sh_flags == '00 00 00 00 00 00 00 01 ':
            print("SHF_WRITE <> Writable")
        elif self.sh_flags == '00 00 00 00 00 00 00 02 ':
            print("SHF_ALLOC <> Occupies memory during execution")
        elif self.sh_flags == '00 00 00 00 00 00 00 04 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        elif self.sh_flags == '00 00 00 01 ':
            print("PT_LOAD <> Lodable segment")
        else:
            print("")

class CODEDATA:
    def __init__(self):
        self.len = ""     
        self.data = ""     
        self.write = "" 
        self.rodata =""
              
    def display(self):
        print("---------------------Code Data---------------------")
        print("len :", self.len)
        print("data :", self.data)
        print("write :", self.write)
        print("Hex dump of section '.rodata':", self.rodata)

#Récupération de la chaine Hexadecimal du ELF
def GetElf(input_file: str):
    with open(input_file, mode='rb') as file:
        return file.read().hex()