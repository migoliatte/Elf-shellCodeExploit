#Class nécessaires


def reverseBinaryCode(str):
    returnString = ''
    i = len(str)
    while i:
        i -= 2                  # index = index - 1
        returnString += str[i]+str[i+1] # new_string = new_string + character
    return returnString

class E_IDENT:
    def __init__(self):
        # 0x7F followed by ELF(45 4c 46) in ASCII; these four bytes constitute the magic number.
        self.ei_mag = ""
        # This byte is set to either 1 or 2 to signify 32- or 64-bit format, respectively.
        self.ei_class = ""
        # This byte is set to either 1 or 2 to signify little or big endianness, respectively. This affects interpretation of multi-byte fields starting with offset 0x10.
        self.ei_data = ""
        # Set to 1 for the original and current version of ELF.
        self.ei_version = ""
        # Identifies the target operating system ABI.It is often set to 0 regardless of the target platform.
        self.ei_osabi = ""
        # This byte identifies the version of the ABI to which the object is targeted. This field is used to distinguish among incompatible versions of an ABI. The interpretation of this version number is dependent on the ABI identified by the EI_OSABI field. Applications conforming to this specification use the value 0.
        self.ei_abiversion = ""
        # Start of padding. These bytes are reserved and set to zero. Programs which read them should ignore them. The value for EI_PAD will change in the future if currently unused bytes are given meanings.
        self.ei_pad = ""

    def display(self):
        print("---------------------E_Ident---------------------")
        self.displayMag()
        self.displayFormat()
        self.displayEndianness()
        self.ei_version="0x"+self.ei_version;print("Version Original du elf :", int(self.ei_version, 16))
        self.displayOsabi()
        self.ei_abiversion="0x"+self.ei_abiversion;print("ei_abiversion:", self.ei_abiversion)
       # print("",self.ei_pad)

    def displayMag(self):
        print("Magic Number :", self.ei_mag, "<>", end=' ')
        if self.ei_mag == '7f 45 4c 46 ':
            print("ELF")
        else:
            print("")

    def displayFormat(self):
        self.ei_class="0x"+self.ei_class;print("Format:", self.ei_class, "<>", end=' ')
        if self.ei_class == '0x01':
            print("32-bit")
        elif self.ei_class == '0x02':
            print("64-bit")
        else:
            print("")

    def displayEndianness(self):
        self.ei_data="0x"+self.ei_data;print("Endianness:", self.ei_data, "<>", end=' ')
        if self.ei_data == '0x01':
            print("(little)")
        elif self.ei_data == '0x02':
            print("(big)")
        else:
            print("")

    def displayOsabi(self):
        self.ei_osabi="0x"+self.ei_osabi;print("Système d'exploitation:", self.ei_osabi, "<>", end=' ')
        if self.ei_osabi == '0x00':
            print("System V")
        elif self.ei_osabi == '0x01':
            print("HP-UX")
        elif self.ei_osabi == '0x02':
            print("NetBSD")
        elif self.ei_osabi == '0x03':
            print("Linux")
        elif self.ei_osabi == '0x04':
            print("GNU Hurd")
        elif self.ei_osabi == '0x06':
            print("Solaris")
        elif self.ei_osabi == '0x07':
            print("AIX")
        elif self.ei_osabi == '0x08':
            print("IRIX")
        elif self.ei_osabi == '0x09':
            print("FreeBSD")
        elif self.ei_osabi == '0x0A':
            print("Tru64")
        elif self.ei_osabi == '0x0B':
            print("Novell Modesto")
        elif self.ei_osabi == '0x0C':
            print("OpenBSD")
        elif self.ei_osabi == '0x0D':
            print("OpenVMS")
        elif self.ei_osabi == '0x0E':
            print("NonStop Kernel")
        elif self.ei_osabi == '0x0F':
            print("AROS")
        elif self.ei_osabi == '0x10':
            print("Fenix OS")
        elif self.ei_osabi == '0x11':
            print("CloudABI")
        elif self.ei_osabi == '0x12':
            print("Stratus Technologies OpenVos")
        else:
            print("")

class FILEHEADER:
    def __init__(self):
        self.e_ident = E_IDENT()
        # Identifies object file type.
        self.e_type = ""
        # Specifies target instruction set architecture.
        self.e_machine = ""
        # Set to 1 for the original version of ELF.
        self.e_version = ""
        # This is the memory address of the entry point from where the process starts executing. This field is either 32 or 64 bits long depending on the format defined earlier.
        self.e_entry = ""
        # Points to the start of the program header table. It usually follows the file header immediately, making the offset 0x34 or 0x40 for 32- and 64-bit ELF executables, respectively.
        self.e_phoff = ""
        # Points to the start of the section header table.
        self.e_shoff = ""
        # Interpretation of this field depends on the target architecture.
        self.e_flags = ""
        # Contains the size of this header, normally 64 Bytes for 64-bit and 52 Bytes for 32-bit format.
        self.e_ehsize = ""
        # Contains the size of a program header table entry.
        self.e_phentsize = ""
        # Contains the number of entries in the program header table.
        self.e_phnum = ""
        # Contains the size of a section header table entry.
        self.e_shentsize = ""
        # Contains the number of entries in the section header table.
        self.e_shnum = ""
        # Contains index of the section header table entry that contains the section names.
        self.e_shstrndx = ""

    def display(self):
        print("---------------------File Header---------------------")
        self.displayType()
        self.displayMachine()
        self.e_version="0x"+reverseBinaryCode(self.e_version);print("Version du ELF :", int(self.e_version, 16))
        self.e_entry="0x"+reverseBinaryCode(self.e_entry);print("Adresse de 'entry point' :", self.e_entry,"soit en byte",int(self.e_entry, 16))
        self.e_phoff="0x"+reverseBinaryCode(self.e_phoff);print("Adresse de du début du programme 'header table'", self.e_phoff,"soit en byte",int(self.e_phoff, 16))
        self.e_shoff="0x"+reverseBinaryCode(self.e_shoff);print("Addresse de la section 'header table':", self.e_shoff,"soit en byte",int(self.e_shoff, 16))
        self.e_flags="0x"+reverseBinaryCode(self.e_flags);print("e_flag :", self.e_flags)
        self.e_ehsize="0x"+reverseBinaryCode(self.e_ehsize);print("Taille du header :", self.e_ehsize,"soit en byte",int(self.e_ehsize, 16))
        self.e_phentsize="0x"+reverseBinaryCode(self.e_phentsize);print("Taille du 'program header table entry':", self.e_phentsize,"soit en byte",int(self.e_phentsize, 16))
        self.e_phnum="0x"+reverseBinaryCode(self.e_phnum);print("Nombre d'entrée dans le 'header table' :", self.e_phnum,"soit en byte",int(self.e_phnum, 16))
        self.e_shentsize="0x"+reverseBinaryCode(self.e_shentsize);print("Taille de la 'section header table entry'", self.e_shentsize,"soit en byte",int(self.e_shentsize, 16))
        self.e_shnum="0x"+reverseBinaryCode(self.e_shnum);print("Nombre d'entrée dans la 'section header table' :", self.e_shnum,"soit en byte",int(self.e_shnum, 16))
        self.e_shstrndx="0x"+reverseBinaryCode(self.e_shstrndx);print("index de l'entrée de table du header de la section qui contient les noms de section :", self.e_shstrndx,"soit en byte",int(self.e_shstrndx, 16))

    def displayType(self):
        self.e_type="0x"+reverseBinaryCode(self.e_type);print("Type de fichier : ",self.e_type, " <> ", end=' ')
        if self.e_type == '0x0000':
            print("ET_NONE")
        elif self.e_type == '0x0001':
            print("ET_REL")
        elif self.e_type == '0x0002':
            print("ET_EXEC")
        elif self.e_type == '0x0003':
            print("ET_DYN")
        elif self.e_type == '0x0004':
            print("ET_CORE")
        elif self.e_type == '0xfe00':
            print("ET_LOOS")
        elif self.e_type == '0xfeff':
            print("ET_HIOS")
        elif self.e_type == '0xff00':
            print("ET_LOPROC")
        elif self.e_type == '0xffff':
            print("ET_HIPROC")
        else:
            print("")
            
    def displayMachine(self):
        self.e_machine="0x"+reverseBinaryCode(self.e_machine);print("Type d'architecture :", self.e_machine, "<>", end=' ')
        if self.e_machine == '0x0000':
            print("")
        elif self.e_machine == '0x0002':
            print("SPARC")
        elif self.e_machine == '0x0003':
            print("x86")
        elif self.e_machine == '0x0008':
            print("MIPS")
        elif self.e_machine == '0x0014':
            print("PowerPC")
        elif self.e_machine == '0x0016':
            print("S390")
        elif self.e_machine == '0x0028':
            print("ARM")
        elif self.e_machine == '0x002a':
            print("SuperH")
        elif self.e_machine == '0x0032':
            print("IA-64")
        elif self.e_machine == '0x003e':
            print("amd64")
        elif self.e_machine == '0x00b7':
            print("AArch64")
        elif self.e_machine == '0x00f3':
            print("RISC-V")
        else:
            print("")
            
class PROGRAMHEADER:
    def __init__(self):
        # Identifies the type of the segment
        self.p_type = ""    
        # Segment-Dependent flags ( position for 64-bit structure )
        self.p_flags = "" 
        # Offset of the segment in the file image
        self.p_offset = "" 
        # Virtual address of the segment in memory
        self.p_vaddr = "" 
        # On systems where physical address is relevant, reserve for segment's physical address
        self.p_paddr = "" 
        # Size in bytes of the segment in the file image. May be 0
        self.p_filesz = "" 
        # Size in bytes of the sement in memory. May be 0
        self.p_memsz = "" 
        # Segment-edpendent flags (position for 32-bit structure)
        # self.p_flags = "" 
        #0 and 1 specify no alignment. Otherwize should be a positive, integral power of 2k with p_vaddr equatin p_offset modulus p_align
        self.p_alin = ""    

    def display(self):
        print("---------------------Program Header---------------------")
        self.displayType()
        self.p_flags="0x"+reverseBinaryCode(self.p_flags);print("p_flags :", self.p_flags,"soit en byte",int(self.p_flags, 16))
        self.p_offset="0x"+reverseBinaryCode(self.p_offset);print("p_offset :", self.p_offset,"soit en byte",int(self.p_offset, 16))
        self.p_vaddr="0x"+reverseBinaryCode(self.p_vaddr);print("p_vaddr :", self.p_vaddr,"soit en byte",int(self.p_vaddr, 16))
        self.p_paddr="0x"+reverseBinaryCode(self.p_paddr);print("p_paddr :", self.p_paddr,"soit en byte",int(self.p_paddr, 16))
        self.p_filesz="0x"+reverseBinaryCode(self.p_filesz);print("p_filesz :", self.p_filesz,"soit en byte",int(self.p_filesz, 16))
        self.p_memsz="0x"+reverseBinaryCode(self.p_memsz);print("p_memsz :", self.p_memsz,"soit en byte",int(self.p_memsz, 16))
        self.p_alin="0x"+reverseBinaryCode(self.p_alin);print("p_alin :", self.p_alin,"soit en byte",int(self.p_alin, 16))

    def displayType(self):
        self.p_type="0x"+reverseBinaryCode(self.p_type);print("p_type :", self.p_type,"<>", end=' ')
        if self.p_type == '0x00000000':
            print("PT_NULL <> Program header table entry unused","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000001':
            print("PT_LOAD <> Lodable segment","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000002':
            print("PT_DYNAMIC <> Dynamic linking information","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000003':
            print("PT_INTERP <> Interpreter information","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000004':
            print("PT_NOTE <> Auxillary information","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000005':
            print("PT_SHLIB <> Reserved","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000006':
            print("PT_PHDR <> Segment containing program header table itself","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x00000007':
            print("PT_TLS <> Thread-Local Storage template","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x60000000':
            print("PT_LOOS <> inclusive reserver ranges for operating system (processor) specific semantics","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x6fffffff':
            print("PT_HIOS <> inclusive reserver ranges for operating system (processor) specific semantics","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x70000000':
            print("PT_LOPROC <> inclusive reserver ranges for operating system (processor) specific semantics","soit en byte",int(self.p_type, 16))
        elif self.p_type == '0x7fffffff':
            print("PT_HIPROC <> inclusive reserver ranges for operating system (processor) specific semantics","soit en byte",int(self.p_type, 16))
        else:
            print("","soit en byte",int(self.p_type, 16))

class SECTIONHEADER:
    def __init__(self):
        # An offset to a string in the .shstrtab section that represents the name of this section
        self.sh_name = ""           
        # Identifies the type of this header.
        self.sh_type = ""    
        # Identifies the attributes of the section.
        self.sh_flags = "" 
        # Virtual address of the section in memory, for sections that are loaded.
        self.sh_addr = "" 
        # Offset of the section in the file image.
        self.sh_offset = "" 
        # Size in bytes of the section in the file image. May be 0.
        self.sh_size = "" 
        # Contains the section index of an associated section. This field is used for several purposes, depending on the type of section.
        self.sh_link = "" 
        # Contains extra information about the section. This field is used for several purposes, depending on the type of section.
        self.sh_info = "" 
        # Contains the required alignment of the section. This field must be a power of two.
        self.sh_addralign = "" 
        # Contains the size, in bytes, of each entry, for sections that contain fixed-size entries. Otherwise, this field contains zero.
        self.sh_entsize = ""    

    def display(self):
        print("--------------------- Section Header Table ---------------------")
        self.sh_name="0x"+reverseBinaryCode(self.sh_name);print("sh_name :", self.sh_name,"soit en byte",int(self.sh_name, 16))
        self.displayType()
        self.displayFlags()
        self.sh_addr="0x"+reverseBinaryCode(self.sh_addr);print("sh_addr :", self.sh_addr,"soit en byte",int(self.sh_addr, 16))
        self.sh_offset="0x"+reverseBinaryCode(self.sh_offset);print("sh_offset :", self.sh_offset,"soit en byte",int(self.sh_offset, 16))
        self.sh_size="0x"+reverseBinaryCode(self.sh_size);print("sh_size :", self.sh_size,"soit en byte",int(self.sh_size, 16))
        self.sh_link="0x"+reverseBinaryCode(self.sh_link);print("sh_link :", self.sh_link,"soit en byte",int(self.sh_link, 16))
        self.sh_info="0x"+reverseBinaryCode(self.sh_info);print("p_flags :", self.sh_info,"soit en byte",int(self.sh_info, 16))
        self.sh_addralign="0x"+reverseBinaryCode(self.sh_addralign);print("sh_addralign :", self.sh_addralign,"soit en byte",int(self.sh_addralign, 16))
        self.sh_entsize="0x"+reverseBinaryCode(self.sh_entsize);print("p_flags :", self.sh_entsize,"soit en byte",int(self.sh_entsize, 16))

    def displayType(self):
        #self.sh_type="0x"+reverseBinaryCode(self.sh_type);print("sh_type :", self.sh_type,"<>", end=' ')
        self.sh_type="0x"+self.sh_type;print("sh_type :", self.sh_type,"<>", end=' ')
        if self.sh_type == '0x00000000':
            print("SHT_NULL <> Section header table entry unused","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000001':
            print("SHT_PROGBITS <> Program data","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000002':
            print("SHT_SYMTAB   <> Symbol table","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000003':
            print("SHT_STRTAB   <> String table","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000004':
            print("SHT_RELA		<> Relocation entries with addends","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000005':
            print("SHT_HASH	 <> Symbol hash table","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000006':
            print("SHT_DYNAMIC	 <> Dynamic linking information","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000007':
            print("SHT_NOTE	 <> Notes","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000008':
            print("SHT_NOBITS	 <> Program space with no data (bss)","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000009':
            print("SHT_REL	 <> Relocation entries, no addends","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x0000000A':
            print("SHT_SHLIB	 <> Reserved","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x0000000B':
            print("SHT_DYNSYM	 <> Dynamic linker symbol table","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x0000000E':
            print("SHT_INIT_ARRAY	 <> Array of constructors","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x0000000F':
            print("SHT_FINI_ARRAY	 <> Array of destructors","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000010':
            print("SHT_PREINIT_ARRAY	 <> Array of pre-constructors","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000011':
            print("SHT_GROUP	 <> Section group ","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000012':
            print("SHT_SYMTAB_SHNDX	 <> Extended section indices ","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x00000013':
            print("SHT_NUM <> Number of defined types.","soit en byte",int(self.sh_type, 16))
        elif self.sh_type == '0x60000000':
            print("SHT_LOOS <> Start OS-specific.","soit en byte",int(self.sh_type, 16))
        else:
            print("","soit en byte",int(self.sh_type, 16))

    def displayFlags(self):
        self.sh_flags="0x"+reverseBinaryCode(self.sh_flags);print("sh_flags :", self.sh_flags,"<>", end=' ')
        if self.sh_flags == '0x0000000000000001':
            print("SHF_WRITE <> Writable","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000002':
            print("SHF_ALLOC <> Occupies memory during execution","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000004':
            print("SHF_EXECINSTR <> Executable","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000010':
            print("SHF_MERGE <> Might be merged","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000020':
            print("SHF_STRINGS <> Contains nul-terminated strings","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000040':
            print("SHF_INFO_LINK <> 'sh_info' contains SHT index","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000080':
            print("SHF_LINK_ORDER <> Preserve order after combining","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000100':
            print("SHF_OS_NONCONFORMING <> Non-standard OS specific handling requiredt","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000200':
            print("SHF_GROUP <> Section is member of a group","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000000000400':
            print("SHF_TLS <> Section hold thread-local data","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x000000000ff00000':
            print("SHF_MASKOS <> OS-specific","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x00000000f0000000':
            print("SHF_MASKPROC <> Processor-specific","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x000000004000000':
            print("SHF_ORDERED <> Special ordering requirement (Solaris)","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x0000000070000000':
            print("SHT_LOPROC <> Cette valeur et les valeurs suivantes jusqu'à SHT_HIPROC (incluse) sont réservées à des sémantiques spécifiques au processeur.","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x000000007fffffff':
            print("SHT_HIPROC <> Cette valeur et les valeurs précédentes depuis SHT_LOPROC (incluse) sont réservées à des sémantiques spécifiques au processeur.","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x000000008000000':
            print("SHF_EXCLUDE <> Section is excluded unless referenced or allocated ","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x00000000ffffffff':
            print("SHT_HIUSER <> Cette valeur indique la borne supérieure de la plage des indices réservés aux programmes applicatifs. Les types des sections entre SHT_LOUSER et SHT_HIUSER peuvent être utilisés par l'application, sans que cela entre en conflit avec les actuels ou futurs types de sections définis par le système.","soit en byte",int(self.sh_type, 16))
        elif self.sh_flags == '0x000000080000000':
            print("SHT_LOUSER <> Cette valeur indique la borne inférieure de la plage des indices réservés aux programmes applicatifs.","soit en byte",int(self.sh_type, 16))
        else:
            print("","soit en byte",int(self.sh_type, 16))

class CODEDATA:
    def __init__(self):
        self.len = ""     
        self.data = ""     
        self.write = "" 
        self.rodata = ""
        self.sectionName = ""
              
    def display(self):
        print("---------------------Code Data---------------------")
        self.len="0x"+reverseBinaryCode(self.len);print("len :", self.len,"soit en byte",int(self.len, 16))
        self.data="0x"+reverseBinaryCode(self.data);print("data :", self.data,"soit en byte",int(self.data, 16))
        self.write="0x"+reverseBinaryCode(self.write);print("write :", self.write,"soit en byte",int(self.write, 16))
        self.rodataOui()
        self.sectionName="0x"+reverseBinaryCode(self.sectionName);print("sectionName :", self.sectionName,"soit en byte",int(self.sectionName, 16))

    def rodataOui(self):       
        self.rodata="0x"+self.rodata;print("Hex dump of section '.rodata': :", self.rodata, end=' ')
        if self.rodata == '0x6f7569206f7569206f7569206f7569206f7569':
            print("<> oui oui oui oui oui","soit en byte",int(self.rodata, 16))

            
#Récupération de la chaine Hexadecimal du ELF
def GetElf(input_file: str):
    with open(input_file, mode='rb') as file:
        return file.read().hex()